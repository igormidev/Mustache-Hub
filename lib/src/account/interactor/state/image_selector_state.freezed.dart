// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'image_selector_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$ImageSelectorState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() withoutImage,
    required TResult Function(Uint8List image, ImageType imageType) withImage,
    required TResult Function(Uint8List image, ImageType imageType) loading,
    required TResult Function(String name, String description,
            ImageType? imageType, Uint8List? image)
        failure,
    required TResult Function(Uint8List image, ImageType imageType)
        imageSelectorUploadSuccess,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? withoutImage,
    TResult? Function(Uint8List image, ImageType imageType)? withImage,
    TResult? Function(Uint8List image, ImageType imageType)? loading,
    TResult? Function(String name, String description, ImageType? imageType,
            Uint8List? image)?
        failure,
    TResult? Function(Uint8List image, ImageType imageType)?
        imageSelectorUploadSuccess,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? withoutImage,
    TResult Function(Uint8List image, ImageType imageType)? withImage,
    TResult Function(Uint8List image, ImageType imageType)? loading,
    TResult Function(String name, String description, ImageType? imageType,
            Uint8List? image)?
        failure,
    TResult Function(Uint8List image, ImageType imageType)?
        imageSelectorUploadSuccess,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WithoutImage value) withoutImage,
    required TResult Function(_WithImage value) withImage,
    required TResult Function(ImageSelectorStateLoading value) loading,
    required TResult Function(ImageSelectorStateFailure value) failure,
    required TResult Function(ImageSelectorUploadSuccess value)
        imageSelectorUploadSuccess,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_WithoutImage value)? withoutImage,
    TResult? Function(_WithImage value)? withImage,
    TResult? Function(ImageSelectorStateLoading value)? loading,
    TResult? Function(ImageSelectorStateFailure value)? failure,
    TResult? Function(ImageSelectorUploadSuccess value)?
        imageSelectorUploadSuccess,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WithoutImage value)? withoutImage,
    TResult Function(_WithImage value)? withImage,
    TResult Function(ImageSelectorStateLoading value)? loading,
    TResult Function(ImageSelectorStateFailure value)? failure,
    TResult Function(ImageSelectorUploadSuccess value)?
        imageSelectorUploadSuccess,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ImageSelectorStateCopyWith<$Res> {
  factory $ImageSelectorStateCopyWith(
          ImageSelectorState value, $Res Function(ImageSelectorState) then) =
      _$ImageSelectorStateCopyWithImpl<$Res, ImageSelectorState>;
}

/// @nodoc
class _$ImageSelectorStateCopyWithImpl<$Res, $Val extends ImageSelectorState>
    implements $ImageSelectorStateCopyWith<$Res> {
  _$ImageSelectorStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_WithoutImageCopyWith<$Res> {
  factory _$$_WithoutImageCopyWith(
          _$_WithoutImage value, $Res Function(_$_WithoutImage) then) =
      __$$_WithoutImageCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_WithoutImageCopyWithImpl<$Res>
    extends _$ImageSelectorStateCopyWithImpl<$Res, _$_WithoutImage>
    implements _$$_WithoutImageCopyWith<$Res> {
  __$$_WithoutImageCopyWithImpl(
      _$_WithoutImage _value, $Res Function(_$_WithoutImage) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_WithoutImage implements _WithoutImage {
  _$_WithoutImage();

  @override
  String toString() {
    return 'ImageSelectorState.withoutImage()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_WithoutImage);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() withoutImage,
    required TResult Function(Uint8List image, ImageType imageType) withImage,
    required TResult Function(Uint8List image, ImageType imageType) loading,
    required TResult Function(String name, String description,
            ImageType? imageType, Uint8List? image)
        failure,
    required TResult Function(Uint8List image, ImageType imageType)
        imageSelectorUploadSuccess,
  }) {
    return withoutImage();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? withoutImage,
    TResult? Function(Uint8List image, ImageType imageType)? withImage,
    TResult? Function(Uint8List image, ImageType imageType)? loading,
    TResult? Function(String name, String description, ImageType? imageType,
            Uint8List? image)?
        failure,
    TResult? Function(Uint8List image, ImageType imageType)?
        imageSelectorUploadSuccess,
  }) {
    return withoutImage?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? withoutImage,
    TResult Function(Uint8List image, ImageType imageType)? withImage,
    TResult Function(Uint8List image, ImageType imageType)? loading,
    TResult Function(String name, String description, ImageType? imageType,
            Uint8List? image)?
        failure,
    TResult Function(Uint8List image, ImageType imageType)?
        imageSelectorUploadSuccess,
    required TResult orElse(),
  }) {
    if (withoutImage != null) {
      return withoutImage();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WithoutImage value) withoutImage,
    required TResult Function(_WithImage value) withImage,
    required TResult Function(ImageSelectorStateLoading value) loading,
    required TResult Function(ImageSelectorStateFailure value) failure,
    required TResult Function(ImageSelectorUploadSuccess value)
        imageSelectorUploadSuccess,
  }) {
    return withoutImage(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_WithoutImage value)? withoutImage,
    TResult? Function(_WithImage value)? withImage,
    TResult? Function(ImageSelectorStateLoading value)? loading,
    TResult? Function(ImageSelectorStateFailure value)? failure,
    TResult? Function(ImageSelectorUploadSuccess value)?
        imageSelectorUploadSuccess,
  }) {
    return withoutImage?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WithoutImage value)? withoutImage,
    TResult Function(_WithImage value)? withImage,
    TResult Function(ImageSelectorStateLoading value)? loading,
    TResult Function(ImageSelectorStateFailure value)? failure,
    TResult Function(ImageSelectorUploadSuccess value)?
        imageSelectorUploadSuccess,
    required TResult orElse(),
  }) {
    if (withoutImage != null) {
      return withoutImage(this);
    }
    return orElse();
  }
}

abstract class _WithoutImage implements ImageSelectorState {
  factory _WithoutImage() = _$_WithoutImage;
}

/// @nodoc
abstract class _$$_WithImageCopyWith<$Res> {
  factory _$$_WithImageCopyWith(
          _$_WithImage value, $Res Function(_$_WithImage) then) =
      __$$_WithImageCopyWithImpl<$Res>;
  @useResult
  $Res call({Uint8List image, ImageType imageType});
}

/// @nodoc
class __$$_WithImageCopyWithImpl<$Res>
    extends _$ImageSelectorStateCopyWithImpl<$Res, _$_WithImage>
    implements _$$_WithImageCopyWith<$Res> {
  __$$_WithImageCopyWithImpl(
      _$_WithImage _value, $Res Function(_$_WithImage) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? image = null,
    Object? imageType = null,
  }) {
    return _then(_$_WithImage(
      image: null == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as Uint8List,
      imageType: null == imageType
          ? _value.imageType
          : imageType // ignore: cast_nullable_to_non_nullable
              as ImageType,
    ));
  }
}

/// @nodoc

class _$_WithImage implements _WithImage {
  _$_WithImage({required this.image, required this.imageType});

  @override
  final Uint8List image;
  @override
  final ImageType imageType;

  @override
  String toString() {
    return 'ImageSelectorState.withImage(image: $image, imageType: $imageType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_WithImage &&
            const DeepCollectionEquality().equals(other.image, image) &&
            (identical(other.imageType, imageType) ||
                other.imageType == imageType));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(image), imageType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_WithImageCopyWith<_$_WithImage> get copyWith =>
      __$$_WithImageCopyWithImpl<_$_WithImage>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() withoutImage,
    required TResult Function(Uint8List image, ImageType imageType) withImage,
    required TResult Function(Uint8List image, ImageType imageType) loading,
    required TResult Function(String name, String description,
            ImageType? imageType, Uint8List? image)
        failure,
    required TResult Function(Uint8List image, ImageType imageType)
        imageSelectorUploadSuccess,
  }) {
    return withImage(image, imageType);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? withoutImage,
    TResult? Function(Uint8List image, ImageType imageType)? withImage,
    TResult? Function(Uint8List image, ImageType imageType)? loading,
    TResult? Function(String name, String description, ImageType? imageType,
            Uint8List? image)?
        failure,
    TResult? Function(Uint8List image, ImageType imageType)?
        imageSelectorUploadSuccess,
  }) {
    return withImage?.call(image, imageType);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? withoutImage,
    TResult Function(Uint8List image, ImageType imageType)? withImage,
    TResult Function(Uint8List image, ImageType imageType)? loading,
    TResult Function(String name, String description, ImageType? imageType,
            Uint8List? image)?
        failure,
    TResult Function(Uint8List image, ImageType imageType)?
        imageSelectorUploadSuccess,
    required TResult orElse(),
  }) {
    if (withImage != null) {
      return withImage(image, imageType);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WithoutImage value) withoutImage,
    required TResult Function(_WithImage value) withImage,
    required TResult Function(ImageSelectorStateLoading value) loading,
    required TResult Function(ImageSelectorStateFailure value) failure,
    required TResult Function(ImageSelectorUploadSuccess value)
        imageSelectorUploadSuccess,
  }) {
    return withImage(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_WithoutImage value)? withoutImage,
    TResult? Function(_WithImage value)? withImage,
    TResult? Function(ImageSelectorStateLoading value)? loading,
    TResult? Function(ImageSelectorStateFailure value)? failure,
    TResult? Function(ImageSelectorUploadSuccess value)?
        imageSelectorUploadSuccess,
  }) {
    return withImage?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WithoutImage value)? withoutImage,
    TResult Function(_WithImage value)? withImage,
    TResult Function(ImageSelectorStateLoading value)? loading,
    TResult Function(ImageSelectorStateFailure value)? failure,
    TResult Function(ImageSelectorUploadSuccess value)?
        imageSelectorUploadSuccess,
    required TResult orElse(),
  }) {
    if (withImage != null) {
      return withImage(this);
    }
    return orElse();
  }
}

abstract class _WithImage implements ImageSelectorState {
  factory _WithImage(
      {required final Uint8List image,
      required final ImageType imageType}) = _$_WithImage;

  Uint8List get image;
  ImageType get imageType;
  @JsonKey(ignore: true)
  _$$_WithImageCopyWith<_$_WithImage> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ImageSelectorStateLoadingCopyWith<$Res> {
  factory _$$ImageSelectorStateLoadingCopyWith(
          _$ImageSelectorStateLoading value,
          $Res Function(_$ImageSelectorStateLoading) then) =
      __$$ImageSelectorStateLoadingCopyWithImpl<$Res>;
  @useResult
  $Res call({Uint8List image, ImageType imageType});
}

/// @nodoc
class __$$ImageSelectorStateLoadingCopyWithImpl<$Res>
    extends _$ImageSelectorStateCopyWithImpl<$Res, _$ImageSelectorStateLoading>
    implements _$$ImageSelectorStateLoadingCopyWith<$Res> {
  __$$ImageSelectorStateLoadingCopyWithImpl(_$ImageSelectorStateLoading _value,
      $Res Function(_$ImageSelectorStateLoading) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? image = null,
    Object? imageType = null,
  }) {
    return _then(_$ImageSelectorStateLoading(
      image: null == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as Uint8List,
      imageType: null == imageType
          ? _value.imageType
          : imageType // ignore: cast_nullable_to_non_nullable
              as ImageType,
    ));
  }
}

/// @nodoc

class _$ImageSelectorStateLoading implements ImageSelectorStateLoading {
  _$ImageSelectorStateLoading({required this.image, required this.imageType});

  @override
  final Uint8List image;
  @override
  final ImageType imageType;

  @override
  String toString() {
    return 'ImageSelectorState.loading(image: $image, imageType: $imageType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ImageSelectorStateLoading &&
            const DeepCollectionEquality().equals(other.image, image) &&
            (identical(other.imageType, imageType) ||
                other.imageType == imageType));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(image), imageType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ImageSelectorStateLoadingCopyWith<_$ImageSelectorStateLoading>
      get copyWith => __$$ImageSelectorStateLoadingCopyWithImpl<
          _$ImageSelectorStateLoading>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() withoutImage,
    required TResult Function(Uint8List image, ImageType imageType) withImage,
    required TResult Function(Uint8List image, ImageType imageType) loading,
    required TResult Function(String name, String description,
            ImageType? imageType, Uint8List? image)
        failure,
    required TResult Function(Uint8List image, ImageType imageType)
        imageSelectorUploadSuccess,
  }) {
    return loading(image, imageType);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? withoutImage,
    TResult? Function(Uint8List image, ImageType imageType)? withImage,
    TResult? Function(Uint8List image, ImageType imageType)? loading,
    TResult? Function(String name, String description, ImageType? imageType,
            Uint8List? image)?
        failure,
    TResult? Function(Uint8List image, ImageType imageType)?
        imageSelectorUploadSuccess,
  }) {
    return loading?.call(image, imageType);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? withoutImage,
    TResult Function(Uint8List image, ImageType imageType)? withImage,
    TResult Function(Uint8List image, ImageType imageType)? loading,
    TResult Function(String name, String description, ImageType? imageType,
            Uint8List? image)?
        failure,
    TResult Function(Uint8List image, ImageType imageType)?
        imageSelectorUploadSuccess,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(image, imageType);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WithoutImage value) withoutImage,
    required TResult Function(_WithImage value) withImage,
    required TResult Function(ImageSelectorStateLoading value) loading,
    required TResult Function(ImageSelectorStateFailure value) failure,
    required TResult Function(ImageSelectorUploadSuccess value)
        imageSelectorUploadSuccess,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_WithoutImage value)? withoutImage,
    TResult? Function(_WithImage value)? withImage,
    TResult? Function(ImageSelectorStateLoading value)? loading,
    TResult? Function(ImageSelectorStateFailure value)? failure,
    TResult? Function(ImageSelectorUploadSuccess value)?
        imageSelectorUploadSuccess,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WithoutImage value)? withoutImage,
    TResult Function(_WithImage value)? withImage,
    TResult Function(ImageSelectorStateLoading value)? loading,
    TResult Function(ImageSelectorStateFailure value)? failure,
    TResult Function(ImageSelectorUploadSuccess value)?
        imageSelectorUploadSuccess,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class ImageSelectorStateLoading implements ImageSelectorState {
  factory ImageSelectorStateLoading(
      {required final Uint8List image,
      required final ImageType imageType}) = _$ImageSelectorStateLoading;

  Uint8List get image;
  ImageType get imageType;
  @JsonKey(ignore: true)
  _$$ImageSelectorStateLoadingCopyWith<_$ImageSelectorStateLoading>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ImageSelectorStateFailureCopyWith<$Res> {
  factory _$$ImageSelectorStateFailureCopyWith(
          _$ImageSelectorStateFailure value,
          $Res Function(_$ImageSelectorStateFailure) then) =
      __$$ImageSelectorStateFailureCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {String name,
      String description,
      ImageType? imageType,
      Uint8List? image});
}

/// @nodoc
class __$$ImageSelectorStateFailureCopyWithImpl<$Res>
    extends _$ImageSelectorStateCopyWithImpl<$Res, _$ImageSelectorStateFailure>
    implements _$$ImageSelectorStateFailureCopyWith<$Res> {
  __$$ImageSelectorStateFailureCopyWithImpl(_$ImageSelectorStateFailure _value,
      $Res Function(_$ImageSelectorStateFailure) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? description = null,
    Object? imageType = freezed,
    Object? image = freezed,
  }) {
    return _then(_$ImageSelectorStateFailure(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      imageType: freezed == imageType
          ? _value.imageType
          : imageType // ignore: cast_nullable_to_non_nullable
              as ImageType?,
      image: freezed == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
    ));
  }
}

/// @nodoc

class _$ImageSelectorStateFailure implements ImageSelectorStateFailure {
  _$ImageSelectorStateFailure(
      {required this.name,
      required this.description,
      required this.imageType,
      required this.image});

  @override
  final String name;
  @override
  final String description;
  @override
  final ImageType? imageType;
  @override
  final Uint8List? image;

  @override
  String toString() {
    return 'ImageSelectorState.failure(name: $name, description: $description, imageType: $imageType, image: $image)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ImageSelectorStateFailure &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.imageType, imageType) ||
                other.imageType == imageType) &&
            const DeepCollectionEquality().equals(other.image, image));
  }

  @override
  int get hashCode => Object.hash(runtimeType, name, description, imageType,
      const DeepCollectionEquality().hash(image));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ImageSelectorStateFailureCopyWith<_$ImageSelectorStateFailure>
      get copyWith => __$$ImageSelectorStateFailureCopyWithImpl<
          _$ImageSelectorStateFailure>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() withoutImage,
    required TResult Function(Uint8List image, ImageType imageType) withImage,
    required TResult Function(Uint8List image, ImageType imageType) loading,
    required TResult Function(String name, String description,
            ImageType? imageType, Uint8List? image)
        failure,
    required TResult Function(Uint8List image, ImageType imageType)
        imageSelectorUploadSuccess,
  }) {
    return failure(name, description, imageType, image);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? withoutImage,
    TResult? Function(Uint8List image, ImageType imageType)? withImage,
    TResult? Function(Uint8List image, ImageType imageType)? loading,
    TResult? Function(String name, String description, ImageType? imageType,
            Uint8List? image)?
        failure,
    TResult? Function(Uint8List image, ImageType imageType)?
        imageSelectorUploadSuccess,
  }) {
    return failure?.call(name, description, imageType, image);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? withoutImage,
    TResult Function(Uint8List image, ImageType imageType)? withImage,
    TResult Function(Uint8List image, ImageType imageType)? loading,
    TResult Function(String name, String description, ImageType? imageType,
            Uint8List? image)?
        failure,
    TResult Function(Uint8List image, ImageType imageType)?
        imageSelectorUploadSuccess,
    required TResult orElse(),
  }) {
    if (failure != null) {
      return failure(name, description, imageType, image);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WithoutImage value) withoutImage,
    required TResult Function(_WithImage value) withImage,
    required TResult Function(ImageSelectorStateLoading value) loading,
    required TResult Function(ImageSelectorStateFailure value) failure,
    required TResult Function(ImageSelectorUploadSuccess value)
        imageSelectorUploadSuccess,
  }) {
    return failure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_WithoutImage value)? withoutImage,
    TResult? Function(_WithImage value)? withImage,
    TResult? Function(ImageSelectorStateLoading value)? loading,
    TResult? Function(ImageSelectorStateFailure value)? failure,
    TResult? Function(ImageSelectorUploadSuccess value)?
        imageSelectorUploadSuccess,
  }) {
    return failure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WithoutImage value)? withoutImage,
    TResult Function(_WithImage value)? withImage,
    TResult Function(ImageSelectorStateLoading value)? loading,
    TResult Function(ImageSelectorStateFailure value)? failure,
    TResult Function(ImageSelectorUploadSuccess value)?
        imageSelectorUploadSuccess,
    required TResult orElse(),
  }) {
    if (failure != null) {
      return failure(this);
    }
    return orElse();
  }
}

abstract class ImageSelectorStateFailure implements ImageSelectorState {
  factory ImageSelectorStateFailure(
      {required final String name,
      required final String description,
      required final ImageType? imageType,
      required final Uint8List? image}) = _$ImageSelectorStateFailure;

  String get name;
  String get description;
  ImageType? get imageType;
  Uint8List? get image;
  @JsonKey(ignore: true)
  _$$ImageSelectorStateFailureCopyWith<_$ImageSelectorStateFailure>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ImageSelectorUploadSuccessCopyWith<$Res> {
  factory _$$ImageSelectorUploadSuccessCopyWith(
          _$ImageSelectorUploadSuccess value,
          $Res Function(_$ImageSelectorUploadSuccess) then) =
      __$$ImageSelectorUploadSuccessCopyWithImpl<$Res>;
  @useResult
  $Res call({Uint8List image, ImageType imageType});
}

/// @nodoc
class __$$ImageSelectorUploadSuccessCopyWithImpl<$Res>
    extends _$ImageSelectorStateCopyWithImpl<$Res, _$ImageSelectorUploadSuccess>
    implements _$$ImageSelectorUploadSuccessCopyWith<$Res> {
  __$$ImageSelectorUploadSuccessCopyWithImpl(
      _$ImageSelectorUploadSuccess _value,
      $Res Function(_$ImageSelectorUploadSuccess) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? image = null,
    Object? imageType = null,
  }) {
    return _then(_$ImageSelectorUploadSuccess(
      image: null == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as Uint8List,
      imageType: null == imageType
          ? _value.imageType
          : imageType // ignore: cast_nullable_to_non_nullable
              as ImageType,
    ));
  }
}

/// @nodoc

class _$ImageSelectorUploadSuccess implements ImageSelectorUploadSuccess {
  _$ImageSelectorUploadSuccess({required this.image, required this.imageType});

  @override
  final Uint8List image;
  @override
  final ImageType imageType;

  @override
  String toString() {
    return 'ImageSelectorState.imageSelectorUploadSuccess(image: $image, imageType: $imageType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ImageSelectorUploadSuccess &&
            const DeepCollectionEquality().equals(other.image, image) &&
            (identical(other.imageType, imageType) ||
                other.imageType == imageType));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(image), imageType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ImageSelectorUploadSuccessCopyWith<_$ImageSelectorUploadSuccess>
      get copyWith => __$$ImageSelectorUploadSuccessCopyWithImpl<
          _$ImageSelectorUploadSuccess>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() withoutImage,
    required TResult Function(Uint8List image, ImageType imageType) withImage,
    required TResult Function(Uint8List image, ImageType imageType) loading,
    required TResult Function(String name, String description,
            ImageType? imageType, Uint8List? image)
        failure,
    required TResult Function(Uint8List image, ImageType imageType)
        imageSelectorUploadSuccess,
  }) {
    return imageSelectorUploadSuccess(image, imageType);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? withoutImage,
    TResult? Function(Uint8List image, ImageType imageType)? withImage,
    TResult? Function(Uint8List image, ImageType imageType)? loading,
    TResult? Function(String name, String description, ImageType? imageType,
            Uint8List? image)?
        failure,
    TResult? Function(Uint8List image, ImageType imageType)?
        imageSelectorUploadSuccess,
  }) {
    return imageSelectorUploadSuccess?.call(image, imageType);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? withoutImage,
    TResult Function(Uint8List image, ImageType imageType)? withImage,
    TResult Function(Uint8List image, ImageType imageType)? loading,
    TResult Function(String name, String description, ImageType? imageType,
            Uint8List? image)?
        failure,
    TResult Function(Uint8List image, ImageType imageType)?
        imageSelectorUploadSuccess,
    required TResult orElse(),
  }) {
    if (imageSelectorUploadSuccess != null) {
      return imageSelectorUploadSuccess(image, imageType);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WithoutImage value) withoutImage,
    required TResult Function(_WithImage value) withImage,
    required TResult Function(ImageSelectorStateLoading value) loading,
    required TResult Function(ImageSelectorStateFailure value) failure,
    required TResult Function(ImageSelectorUploadSuccess value)
        imageSelectorUploadSuccess,
  }) {
    return imageSelectorUploadSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_WithoutImage value)? withoutImage,
    TResult? Function(_WithImage value)? withImage,
    TResult? Function(ImageSelectorStateLoading value)? loading,
    TResult? Function(ImageSelectorStateFailure value)? failure,
    TResult? Function(ImageSelectorUploadSuccess value)?
        imageSelectorUploadSuccess,
  }) {
    return imageSelectorUploadSuccess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WithoutImage value)? withoutImage,
    TResult Function(_WithImage value)? withImage,
    TResult Function(ImageSelectorStateLoading value)? loading,
    TResult Function(ImageSelectorStateFailure value)? failure,
    TResult Function(ImageSelectorUploadSuccess value)?
        imageSelectorUploadSuccess,
    required TResult orElse(),
  }) {
    if (imageSelectorUploadSuccess != null) {
      return imageSelectorUploadSuccess(this);
    }
    return orElse();
  }
}

abstract class ImageSelectorUploadSuccess implements ImageSelectorState {
  factory ImageSelectorUploadSuccess(
      {required final Uint8List image,
      required final ImageType imageType}) = _$ImageSelectorUploadSuccess;

  Uint8List get image;
  ImageType get imageType;
  @JsonKey(ignore: true)
  _$$ImageSelectorUploadSuccessCopyWith<_$ImageSelectorUploadSuccess>
      get copyWith => throw _privateConstructorUsedError;
}
